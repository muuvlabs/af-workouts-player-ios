// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name WorkoutsPlayerCoreInternal
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import CallKit
import Foundation
import HealthKit
import MediaPlayer
import MuuvEndpointsRenamedForCore
import MuuvUtilitiesRenamedForCore
import Swift
import SwiftUI
import UIKit
@_exported import WorkoutsPlayerCoreInternal
import _Concurrency
import _StringProcessing
extension Swift.Array {
  public static func + (all: Swift.Array<Element>, element: Element) -> Swift.Array<Element>
  public mutating func remove(where predicate: (Element) -> Swift.Bool)
  public var countIsOdd: Swift.Bool {
    get
  }
}
extension Swift.Array {
  public mutating func change(where predicate: (Element) -> Swift.Bool, transformation: (inout Element) -> Swift.Void)
}
public protocol AudioCoachingEngine : WorkoutsPlayerCoreInternal.EngineAudioDownloading, WorkoutsPlayerCoreInternal.EngineWorkoutControlling, WorkoutsPlayerCoreInternal.EngineWorkoutInformation {
  init(workout: WorkoutsPlayerCoreInternal.Workout, delegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDelegate?, downloadingDelegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDownloadingDelegate?)
  var delegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDelegate? { get set }
  var downloadingDelegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDownloadingDelegate? { get set }
  var controlsDelegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineControlsDelegate { get }
}
public protocol EngineAudioDownloading {
  var bytesToDownload: Swift.Int64 { get }
  var bytesDownloaded: Swift.Int64 { get }
}
public protocol EngineWorkoutControlling {
  var canStartWorkout: Swift.Bool { get }
  var canPauseWorkout: Swift.Bool { get }
  var canResumeWorkout: Swift.Bool { get }
  var canFinishWorkout: Swift.Bool { get }
  var canDiscardWorkout: Swift.Bool { get }
  var canDecreaseIntensity: Swift.Bool { get }
  var canIncreaseIntensity: Swift.Bool { get }
  var canReplaceBlock: Swift.Bool { get }
  var canSkipBlock: Swift.Bool { get }
  var canMarkBlockAsDone: Swift.Bool { get }
  var isPlaying: Swift.Bool { get }
  func start()
  func finish()
  func discard()
  func pause()
  func resume()
  func decreaseIntensity()
  func increaseIntensity()
  func skipBlock()
  func markBlockDone()
  func replaceBlock()
  func stopPlayingCurrentBlock()
  func setCurrentBlock(_ block: WorkoutsPlayerCoreInternal.WorkoutBlock?, isAlreadySelected: Swift.Bool)
  func dismissBump()
  func cancelReactiveAudio(info: WorkoutsPlayerCoreInternal.CancelReactiveAudioInfo)
  func dismissReactiveAudio(info: WorkoutsPlayerCoreInternal.DismissReactiveAudioInfo)
  func playWhenIsPossible(reactiveAudioSnippet: WorkoutsPlayerCoreInternal.ReactiveAudioSnippet)
}
public protocol EngineWorkoutInformation {
  var didReceiveInfoFromWatch: Swift.Bool { get set }
  var avgHeartRate: Swift.Int { get set }
  var heartRate: Swift.Int { get set }
  var calories: Swift.Int { get set }
  var userWeight: Swift.Int { get set }
  var coachVolume: Swift.Float { get set }
  var currentBlock: WorkoutsPlayerCoreInternal.WorkoutBlock? { get }
  var currentBlockElapsedTime: Foundation.TimeInterval { get }
  var currentBlockProgressFloat: Swift.Float { get }
  var elapsedTime: Foundation.TimeInterval { get }
  var isFormEnabled: Swift.Bool { get set }
  var isMotivationEnabled: Swift.Bool { get set }
  var isDirectionEnabled: Swift.Bool { get set }
  var isPacingEnabled: Swift.Bool { get set }
  var isBumpsEnabled: Swift.Bool { get set }
  var isPaused: Swift.Bool { get }
  var isStarted: Swift.Bool { get }
  var volume: Swift.Float { get set }
  var workout: WorkoutsPlayerCoreInternal.Workout { get }
}
public protocol AudioCoachingEngineControlsDelegate : AnyObject {
  func controlsDidToggle(type: WorkoutsPlayerCoreInternal.AudioCoachingType, newValue: Swift.Bool)
  func controlsDidChangeValue(value: Swift.Float)
  func controlsDidReceiveTap()
}
public enum AudioCoachingType : Swift.Int, Swift.Hashable, Swift.Equatable {
  case direction
  case form
  case motivation
  case pacing
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol AudioCoachingEngineDelegate : WorkoutsPlayerCoreInternal.AudioCoachingEngineBumpsDelegate, WorkoutsPlayerCoreInternal.AudioCoachingEngineWorkoutActionsDelegate, WorkoutsPlayerCoreInternal.AudioCoachingEngineWorkoutDelegate, WorkoutsPlayerCoreInternal.AudioCoachingEngineWorkoutPlaybackDelegate {
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, elapsedTime: Foundation.TimeInterval)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didReceiveInterruptionToPause: WorkoutsPlayerCoreInternal.InterruptionNotification)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didReceiveInterruptionToResume: WorkoutsPlayerCoreInternal.InterruptionNotification)
  func engineDidReceiveEventWorkoutUpdate(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didStartPlayingReactiveAudioSnippet reactiveAudioSnippet: WorkoutsPlayerCoreInternal.ReactiveAudioSnippet)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didStopPlayingReactiveAudioSnippet reactiveAudioSnippet: WorkoutsPlayerCoreInternal.ReactiveAudioSnippet)
  func engineShouldObtainAVGHeartRateFromExternalSource(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine) -> Swift.Bool
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, externalSourceAVGHeartRateSince since: Foundation.Date, toEndDate end: Foundation.Date, completionHandler: @escaping (Foundation.NSNumber?, Swift.Error?) -> Swift.Void)
}
public protocol AudioCoachingEngineWorkoutPlaybackDelegate : AnyObject {
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didStartPlaying eventURL: Foundation.URL)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didStopPlaying eventURL: Foundation.URL)
}
public protocol AudioCoachingEngineWorkoutDelegate : AnyObject {
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, willStart workout: WorkoutsPlayerCoreInternal.Workout)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didStart workout: WorkoutsPlayerCoreInternal.Workout)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didDiscard workout: WorkoutsPlayerCoreInternal.Workout)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didFinish workout: WorkoutsPlayerCoreInternal.Workout, heartRate: Swift.Int, calories: Swift.Int)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didStartBlock block: WorkoutsPlayerCoreInternal.WorkoutBlock)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didFinishBlock block: WorkoutsPlayerCoreInternal.WorkoutBlock)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didPause block: WorkoutsPlayerCoreInternal.WorkoutBlock)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didResume block: WorkoutsPlayerCoreInternal.WorkoutBlock)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didChange block: WorkoutsPlayerCoreInternal.WorkoutBlock)
}
public protocol AudioCoachingEngineWorkoutActionsDelegate : AnyObject {
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, willPerform action: WorkoutsPlayerCoreInternal.UpdateWorkoutAction)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didPerform action: WorkoutsPlayerCoreInternal.UpdateWorkoutAction)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didFail action: WorkoutsPlayerCoreInternal.UpdateWorkoutAction, error: Swift.Error?)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, requests action: WorkoutsPlayerCoreInternal.UpdateWorkoutAction, on workout: WorkoutsPlayerCoreInternal.Workout, retryCount: Swift.Int, onSuccess: @escaping (WorkoutsPlayerCoreInternal.Workout) -> Swift.Void, onError: @escaping (Swift.Error) -> Swift.Void)
}
public protocol AudioCoachingEngineBumpsDelegate : AnyObject {
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, willStartPlayingBump bump: WorkoutsPlayerCoreInternal.Bump, timeSinceNow: Foundation.TimeInterval)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didStartPlayingBump bump: WorkoutsPlayerCoreInternal.Bump)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didStopPlayingBump bump: WorkoutsPlayerCoreInternal.Bump)
}
public protocol AudioCoachingEngineDownloadingDelegate : AnyObject {
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, willStartDownloading workout: WorkoutsPlayerCoreInternal.Workout)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didFinishDownloading workout: WorkoutsPlayerCoreInternal.Workout)
  func engine(_ engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine, didProgressDownloading workout: WorkoutsPlayerCoreInternal.Workout)
}
public struct AudioCoachingPreference : Swift.Codable, WorkoutsPlayerCoreInternal.WorkoutUpdate {
  public let id: Swift.Int
  public let coachId: Swift.Int?
  public let isAudioDirection: Swift.Bool?
  public let isAudioMotivation: Swift.Bool?
  public let isAudioForm: Swift.Bool?
  public let isAudioPacing: Swift.Bool?
  public init(id: Swift.Int, coachId: Swift.Int?, isAudioDirection: Swift.Bool?, isAudioMotivation: Swift.Bool?, isAudioForm: Swift.Bool?, isAudioPacing: Swift.Bool?)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public class AudioControlCenter {
  weak public var delegate: WorkoutsPlayerCoreInternal.AudioControlCenterDelegate?
  public init(delegate: WorkoutsPlayerCoreInternal.AudioControlCenterDelegate)
  @objc deinit
  public func updateNowPlaying()
  public func setNowPlayingMetadata(_ metadata: WorkoutsPlayerCoreInternal.NowPlayableStaticMetadata)
  public func setNowPlayingPlaybackInfo(_ metadata: WorkoutsPlayerCoreInternal.NowPlayableDynamicMetadata)
  public func clearNowPlayingInfo()
}
public protocol AudioControlCenterDelegate : AnyObject {
  var staticMetadata: WorkoutsPlayerCoreInternal.NowPlayableStaticMetadata? { get }
  var dynamicMetadata: WorkoutsPlayerCoreInternal.NowPlayableDynamicMetadata { get }
  func play(fromBegining: Swift.Bool)
  func next()
  func prev()
  func pause()
  func stop()
}
public protocol AudioPlayer : AnyObject {
  var volume: Swift.Float { get set }
  var delegate: WorkoutsPlayerCoreInternal.AudioPlayerDelegate? { get set }
  func play(url: Foundation.URL)
  func seek(time: Foundation.TimeInterval)
  func stop()
  func resume()
  func pause()
}
@objc public class AudioPlayerImp : ObjectiveC.NSObject, WorkoutsPlayerCoreInternal.AudioPlayer {
  weak public var delegate: WorkoutsPlayerCoreInternal.AudioPlayerDelegate?
  public init(delegate: WorkoutsPlayerCoreInternal.AudioPlayerDelegate? = nil, volume: Swift.Float = 1.0)
  public var isPlaying: Swift.Bool {
    get
  }
  public var volume: Swift.Float {
    get
    set
  }
  public func pause()
  public func play(url: Foundation.URL)
  public func seek(time: Foundation.TimeInterval)
  public func stop()
  public func resume()
  public var currentItemDuration: Foundation.TimeInterval? {
    get
  }
  @objc deinit
}
public protocol AudioPlayerDelegate : AnyObject {
  func player(_ player: WorkoutsPlayerCoreInternal.AudioPlayer, didUpdate url: Foundation.URL, currentTime: CoreMedia.CMTime, duration: CoreMedia.CMTime)
  func player(_ player: WorkoutsPlayerCoreInternal.AudioPlayer, didPlayToEnd url: Foundation.URL)
}
public typealias AudioPlayerUpdated = (_ current: CoreMedia.CMTime, _ duration: CoreMedia.CMTime) -> Swift.Void
public class AudioSessionManager {
  public init(audioSession: AVFAudio.AVAudioSession = .sharedInstance())
  public var isOtherAudioPlaying: Swift.Bool {
    get
  }
  public func setupDuckOthers() throws
  public func setupMixWithOthers() throws
  public func setupAudioSession(category: AVFAudio.AVAudioSession.Category = .playback, mode _: AVFAudio.AVAudioSession.Mode = .default, options: AVFAudio.AVAudioSession.CategoryOptions = []) throws
  public func deactivateAudioSession() throws
  @objc deinit
}
public protocol AudioTimelinePlayerDelegate : AnyObject {
  func audioTimelinePlayer(_ player: WorkoutsPlayerCoreInternal.AudioTimelinePlayer, didFire event: WorkoutsPlayerCoreInternal.TimelineEvent)
  func audioTimelinePlayer(_ player: WorkoutsPlayerCoreInternal.AudioTimelinePlayer, willPlay event: WorkoutsPlayerCoreInternal.TimelineEvent, at startTime: Foundation.TimeInterval)
  func audioTimelinePlayer(_ player: WorkoutsPlayerCoreInternal.AudioTimelinePlayer, didProgress progress: WorkoutsPlayerCoreInternal.AudioTimelinePlayer.Progress)
  func audioTimelinePlayer(_ player: WorkoutsPlayerCoreInternal.AudioTimelinePlayer, didFinish event: WorkoutsPlayerCoreInternal.TimelineEvent)
}
public class AudioTimelinePlayer {
  public struct Progress {
    public var time: Foundation.TimeInterval
    public var duration: Foundation.TimeInterval
    public var event: WorkoutsPlayerCoreInternal.TimelineEvent
    public var isLastEvent: Swift.Bool
    public var isFinished: Swift.Bool {
      get
    }
  }
  weak public var delegate: WorkoutsPlayerCoreInternal.AudioTimelinePlayerDelegate?
  public var isPlayingStarted: Swift.Bool {
    get
  }
  public var timeline: WorkoutsPlayerCoreInternal.Timeline {
    get
    set
  }
  public init(timeline: WorkoutsPlayerCoreInternal.Timeline, player: WorkoutsPlayerCoreInternal.AudioPlayer, shouldFillWithSilence: Swift.Bool = true, delegate: WorkoutsPlayerCoreInternal.AudioTimelinePlayerDelegate? = nil)
  @objc deinit
  public func play(startTime: Foundation.TimeInterval, keepPlayingSilenceAfrerDone: Swift.Bool = true)
  public func pause()
  public func resume()
  public func stop()
  public var progress: Swift.Float {
    get
  }
  public var timeRemaining: Swift.Float {
    get
  }
  public func canPlayBump(for bumpDuration: Swift.Float) -> Swift.Bool
  public func addToPlay(bumpTimelineEvent: WorkoutsPlayerCoreInternal.TimelineEvent, duration: Swift.Float)
  public func addToPlay(timelineEvent: WorkoutsPlayerCoreInternal.TimelineEvent, duration: Swift.Float)
  public var hasBumpsToPlay: Swift.Bool {
    get
  }
  public var isTimelineEmpty: Swift.Bool {
    get
  }
  public var hasPendingEventsToPlay: Swift.Bool {
    get
  }
  public var hasReactiveAudioSnippetToPlay: Swift.Bool {
    get
  }
  public func canPlayReactiveAudioSnippet(for duration: Swift.Float) -> Swift.Bool
}
extension WorkoutsPlayerCoreInternal.AudioTimelinePlayer : WorkoutsPlayerCoreInternal.TimelineDelegate {
  public func timeline(_: WorkoutsPlayerCoreInternal.Timeline, didFire event: WorkoutsPlayerCoreInternal.TimelineEvent)
  public func dismissCurrentTimeline()
}
extension WorkoutsPlayerCoreInternal.AudioTimelinePlayer : WorkoutsPlayerCoreInternal.AudioPlayerDelegate {
  public func player(_: WorkoutsPlayerCoreInternal.AudioPlayer, didUpdate _: Foundation.URL, currentTime: CoreMedia.CMTime, duration: CoreMedia.CMTime)
  public func player(_: WorkoutsPlayerCoreInternal.AudioPlayer, didPlayToEnd url: Foundation.URL)
  public func removeBumpTimelineEvents()
  public func removeReactiveAudioSnippetEvents()
}
extension Foundation.URL {
  public static var silence: Foundation.URL {
    get
  }
  public static var bumpIntro: Foundation.URL {
    get
  }
}
extension WorkoutsPlayerCoreInternal.TimelineEvent {
  public static func silence(time: Foundation.TimeInterval = 0, duration: Foundation.TimeInterval = 10) -> WorkoutsPlayerCoreInternal.TimelineEvent
  public var isSilence: Swift.Bool {
    get
  }
  public static func bumpIntro() -> WorkoutsPlayerCoreInternal.TimelineEvent
  public var isBumpIntro: Swift.Bool {
    get
  }
}
public struct AudioTrack : Swift.Encodable, Swift.Equatable {
  public let startMs: Swift.Double
  public let mp3: Swift.String
  public let durationMs: Swift.Double
  public static func == (a: WorkoutsPlayerCoreInternal.AudioTrack, b: WorkoutsPlayerCoreInternal.AudioTrack) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
}
extension WorkoutsPlayerCoreInternal.AudioTrack : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension AVFoundation.AVPlayer {
  public var isPlaying: Swift.Bool {
    get
  }
  public var isPaused: Swift.Bool {
    get
  }
  public var isReady: Swift.Bool {
    get
  }
}
public class BatchDownloader {
  public var batchDownload: WorkoutsPlayerCoreInternal.BatchDownload
  public init(batch: [Foundation.URL], downloader: WorkoutsPlayerCoreInternal.Downloader = .backgroundShared)
  public func download(bundle _: Foundation.Bundle = .main, storageType _: WorkoutsPlayerCoreInternal.StorageType = .cache, onUpdate: @escaping WorkoutsPlayerCoreInternal.Handler<WorkoutsPlayerCoreInternal.BatchDownloadResult>)
  @objc deinit
}
public class BatchDownload {
  public var downloads: [WorkoutsPlayerCoreInternal.AssetDownload]
  public init(downloads: [WorkoutsPlayerCoreInternal.AssetDownload])
  public var isSuccessfullyFinished: Swift.Bool {
    get
  }
  public func download(for url: Foundation.URL) -> WorkoutsPlayerCoreInternal.AssetDownload?
  public var failedDownloads: [WorkoutsPlayerCoreInternal.AssetDownload] {
    get
  }
  public var containsFailedDownloads: Swift.Bool {
    get
  }
  public var flatProgress: Swift.Float {
    get
  }
  public var progress: WorkoutsPlayerCoreInternal.BatchDownloadProgress {
    get
  }
  public var bytesDownloaded: Swift.Int64 {
    get
  }
  public var bytesExpectedToDownload: Swift.Int64 {
    get
  }
  @objc deinit
}
public enum BatchDownloadResult {
  case failure(Swift.Error)
  case finished(WorkoutsPlayerCoreInternal.BatchDownload)
  case progress(WorkoutsPlayerCoreInternal.BatchDownload)
}
public protocol BatchDownloadable {
  var downloadList: [Foundation.URL] { get }
}
public class AssetDownload {
  public var url: Foundation.URL
  public var totalBytesWritten: Swift.Int64
  public var totalBytesExpectedToWrite: Swift.Int64
  public var downloadResult: WorkoutsPlayerCoreInternal.DownloadResult?
  public init(url: Foundation.URL, totalBytesWritten: Swift.Int64 = 0, totalBytesExpectedToWrite: Swift.Int64 = 0, downloadResult: WorkoutsPlayerCoreInternal.DownloadResult? = nil)
  public var progress: Swift.Float? {
    get
  }
  public var downloadedURL: Foundation.URL? {
    get
  }
  public var isInProgress: Swift.Bool {
    get
  }
  public func completeBytesWritten()
  public var isSuccessfullyFinished: Swift.Bool {
    get
  }
  public var isFailed: Swift.Bool {
    get
  }
  public var error: Swift.Error? {
    get
  }
  @objc deinit
}
public typealias ElementFetch<Element> = (@escaping WorkoutsPlayerCoreInternal.Handler<Swift.Result<Element, Swift.Error>>) -> Swift.Void where Element : Swift.Decodable, Element : Swift.Encodable
public enum BatchDownloadProgress {
  case unknownForSomeParts
  case known(Swift.Float)
  public var value: Swift.Float? {
    get
  }
}
public struct BuildSmartWorkoutInfo : Swift.Codable {
  public let streamId: Swift.Int?
  public var durationSeconds: Swift.Int?
  public var equipment: Swift.String?
  public var intensityMod: Swift.String?
  public var coachId: Swift.Int?
  public var isAudioMotivation: Swift.Bool?
  public var isAudioForm: Swift.Bool?
  public var isAudioDirection: Swift.Bool?
  public var isAudioPacing: Swift.Bool?
  public init(streamId: Swift.Int?, durationSeconds: Swift.Int? = nil, equipment: Swift.String? = nil, intensityMod: Swift.String? = nil, coachId: Swift.Int? = nil, isAudioMotivation: Swift.Bool? = nil, isAudioForm: Swift.Bool? = nil, isAudioDirection: Swift.Bool? = nil, isAudioPacing: Swift.Bool? = nil)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@objc public class Bump : ObjectiveC.NSObject, Swift.Codable {
  public var id: Swift.Int?
  public var _id: Swift.String?
  public var createdInt: Swift.Double?
  public var audioMp3: Swift.String?
  public var durationMs: Swift.Double?
  public var waveformPng: Swift.String?
  public var creatorName: Swift.String?
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case id
    case _id
    case createdInt
    case audioMp3
    case durationMs
    case waveformPng
    case creatorName
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  required public init(from decoder: Swift.Decoder) throws
  public var duration: Foundation.TimeInterval {
    get
  }
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
@objc public class WebSocketBumpMessage : ObjectiveC.NSObject, Swift.Codable {
  public var type: Swift.String?
  public var message: WorkoutsPlayerCoreInternal.Bump?
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
@objc public class IsPlayedBump : ObjectiveC.NSObject, Swift.Codable {
  public var isPlayed: Swift.Bool
  public init(isPlayed: Swift.Bool)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension Foundation.Bundle {
  public var displayName: Swift.String? {
    get
  }
  public var versionNumber: Swift.String? {
    get
  }
  public var buildNumber: Swift.String? {
    get
  }
  public var versionAndBuildNumbersWithUnderscores: Swift.String? {
    get
  }
  public var versionAndBuildNumbersWithoutUnderscores: Swift.String? {
    get
  }
  public var versionAndBuildNumbers: Swift.String? {
    get
  }
}
extension Foundation.Calendar {
  public func haveSameYearMonthDay(_ lhs: Foundation.Date, _ rhs: Foundation.Date, in timezone: Foundation.TimeZone) -> Swift.Bool
  public func dateWithSameComponents(as date: Foundation.Date, in timezone: Foundation.TimeZone) -> Foundation.Date?
  public func inTimeZone(_ timeZone: Foundation.TimeZone) -> Foundation.Calendar
  public func remainingDaysInMonth(of date: Foundation.Date, timeZone: Foundation.TimeZone? = nil) -> Swift.Int
  public func remainingDaysInMonth(year: Swift.Int, month: Swift.Int, day: Swift.Int) -> Swift.Int
  public func numberOfDaysIn(month: Swift.Int, year: Swift.Int) -> Swift.Int
  public func numberOfDaysInMonth(of date: Foundation.Date) -> Swift.Int
  public func numberOfDaysInNextMonth(of date: Foundation.Date, timeZone: Foundation.TimeZone? = nil) -> Swift.Int
}
public struct Coach : Swift.Codable {
  public let className: Swift.String
  public let id: Swift.Int
  public let name: Swift.String
  public let style: Swift.String?
  public let description: Swift.String?
  public let url: Swift.String?
  public let posterId: Swift.Int?
  public let streamId: Swift.Int?
  public let stream: WorkoutsPlayerCoreInternal.Stream?
  public let priority: Swift.Int?
  public let gender: Swift.String?
  public let totalPlays: Swift.Int?
  public let startInt: Swift.Double?
  public let isPublished: Swift.Bool?
  public let isPopular: Swift.Bool?
  public let isNew: Swift.Bool?
  public let isYoga: Swift.Bool?
  public let poster: Swift.String?
  public let thumbnail: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Swift.Collection {
  public subscript(safe index: Self.Index) -> Self.Iterator.Element? {
    get
  }
}
public enum Constants {
  public static let minimumBlockIntensity: Swift.Int
  public enum WorkoutBlock {
    public static var noRestBetweenSets: Swift.String
    public static func restTimeText(fromSeconds seconds: Swift.Int?) -> Swift.String
  }
}
extension Foundation.Data {
  public var prettyPrintedJSONString: Swift.String? {
    get
  }
  public var prettyPrintedJSONDictionary: [Swift.String : Any]? {
    get
  }
}
extension Foundation.Date {
  public var millisecondsSince1970: Foundation.TimeInterval {
    get
  }
  public init(milliseconds: Foundation.TimeInterval)
  public func millisecondsForHoursAndMinutes(in timeZone: Foundation.TimeZone) -> Foundation.TimeInterval
  public func month(in timeZone: Foundation.TimeZone, calendar: Foundation.Calendar = Calendar.current) -> Swift.Int
  public func hour(in timeZone: Foundation.TimeZone, calendar: Foundation.Calendar = Calendar.current) -> Swift.Int
  public func minute(in timeZone: Foundation.TimeZone, calendar: Foundation.Calendar = Calendar.current) -> Swift.Int
  public func dayNumber(in timeZone: Foundation.TimeZone, calendar: Foundation.Calendar = Calendar.current) -> Swift.String
  public static func dateFrom(YYYYMMDD dateString: Swift.String, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar = Calendar.current) -> Foundation.Date?
  public func isSameMonth(than otherDate: Foundation.Date, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar = Calendar.current) -> Swift.Bool
  public func adding(hours: Swift.Int, minutes: Swift.Int = 0, seconds: Swift.Int = 0, calendar: Foundation.Calendar = Calendar.current, timeZone: Foundation.TimeZone) -> Foundation.Date
  public func adding(days: Swift.Int, hours: Swift.Int = 0, minutes: Swift.Int = 0, seconds: Swift.Int = 0, calendar: Foundation.Calendar = Calendar.current, timeZone: Foundation.TimeZone) -> Foundation.Date
  public func atZeroHours(calendar: Foundation.Calendar = Calendar.current, in timeZone: Foundation.TimeZone) -> Foundation.Date
  public func dateWithHourMinute(from another: Foundation.Date, calendar: Foundation.Calendar = Calendar.current, in timeZone: Foundation.TimeZone) -> Foundation.Date?
  public func asString(in timezone: Foundation.TimeZone) -> Swift.String
  public func hourAndMinutesAsString(in timezone: Foundation.TimeZone) -> Swift.String
  public func seconds(calendar: Foundation.Calendar = Calendar.current) -> Swift.Int
  public static var nextYear: Foundation.Date {
    get
  }
  public static var pastYear: Foundation.Date {
    get
  }
}
extension Foundation.DateFormatter {
  convenience public init(format: Swift.String, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar = Calendar.current)
}
extension Foundation.Date {
  public func formattedForClassList(timeZone: Foundation.TimeZone) -> Swift.String
  public func ordinalDayNumber(for dayNumber: Swift.String) -> Swift.String
}
extension Swift.Encodable {
  public subscript(key: Swift.String) -> Any? {
    get
  }
  public var dictionary: [Swift.String : Any] {
    get
  }
}
extension Swift.Decodable {
  public init(dictionary: [Swift.String : Any]) throws
}
extension Dispatch.DispatchQueue {
  public func asyncAfter(seconds: Foundation.TimeInterval, execute action: @escaping WorkoutsPlayerCoreInternal.Action)
}
extension Dispatch.DispatchQueue {
  public static func mainSync(block: () -> Swift.Void)
}
public protocol Disposable {
  func dispose()
  func disposed(by disposeBag: WorkoutsPlayerCoreInternal.DisposeBag)
}
extension WorkoutsPlayerCoreInternal.Disposable {
  public func disposed(by disposeBag: WorkoutsPlayerCoreInternal.DisposeBag)
}
public class DisposeBag {
  public init(elements: [WorkoutsPlayerCoreInternal.Disposable] = [])
  @objc deinit
}
public struct ClosureDisposable : WorkoutsPlayerCoreInternal.Disposable {
  public func dispose()
}
public struct DisposeNothing : WorkoutsPlayerCoreInternal.Disposable {
  public func dispose()
}
@_hasMissingDesignatedInitializers public class CompositeDisposable : WorkoutsPlayerCoreInternal.Disposable {
  public func merge(_ disposable: WorkoutsPlayerCoreInternal.Disposable)
  public func dispose()
  @objc deinit
}
public enum Dispose {
  public static var nothing: WorkoutsPlayerCoreInternal.DisposeNothing {
    get
  }
  public static var composite: WorkoutsPlayerCoreInternal.CompositeDisposable {
    get
  }
}
@objc public class Downloader : ObjectiveC.NSObject {
  public static var backgroundShared: WorkoutsPlayerCoreInternal.Downloader
  public var backgroundCompletionHandler: WorkoutsPlayerCoreInternal.Action?
  public init(sessionConfiguration: Foundation.URLSessionConfiguration = .default, backgroundCompletionHandler: WorkoutsPlayerCoreInternal.Action? = nil)
  @discardableResult
  public func download(url: Foundation.URL, usePreviousDownload: Swift.Bool = true, bundle: Foundation.Bundle, countOfBytesClientExpectsToSend: Swift.Int64 = 200, countOfBytesExpectedToReceive: Swift.Int64 = 200, storageType: WorkoutsPlayerCoreInternal.StorageType = .cache, progress: @escaping (Swift.Int64, Swift.Int64) -> Swift.Void, completion: @escaping (WorkoutsPlayerCoreInternal.DownloadResult) -> Swift.Void) -> Foundation.URLSessionDownloadTask?
  public func cancel(downloadTask: Foundation.URLSessionDownloadTask)
  public func pause()
  public func resume()
  @objc deinit
}
extension WorkoutsPlayerCoreInternal.Downloader : Foundation.URLSessionDelegate, Foundation.URLSessionDownloadDelegate {
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic public func urlSessionDidFinishEvents(forBackgroundURLSession _: Foundation.URLSession)
}
public enum DownloaderError : Swift.Error {
  case unableToCreateDestinationPath
  case unableToObtainHTTPResponse
  case unableToCreateTask
  case unableToResumeTaskNotFound
  case unableToResumeNoResumeData
  case invalidHTTPResponseStatusCode(Swift.Int)
}
public enum DownloadResult : Swift.CustomStringConvertible {
  case downloadFinished(Foundation.URL)
  case alreadyDownloadedAtPath(Foundation.URL)
  case error(Swift.Error)
  case cancelled
  public var description: Swift.String {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isError: Swift.Bool {
    get
  }
  public var isFinishedSuccessfully: Swift.Bool {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
public func downsample(imageData: Foundation.Data, to frameSize: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat) throws -> UIKit.UIImage
public func downsample(imageAt imageURL: Foundation.URL, to size: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat) throws -> UIKit.UIImage
public enum AppError : Swift.Error {
  case downsamplingImage
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: WorkoutsPlayerCoreInternal.AppError, b: WorkoutsPlayerCoreInternal.AppError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Encodable {
  public func toJSON(keyEncodingStrategy: Foundation.JSONEncoder.KeyEncodingStrategy = .convertToSnakeCase) throws -> Foundation.Data
  public func toDictionary(keyEncodingStrategy: Foundation.JSONEncoder.KeyEncodingStrategy = .convertToSnakeCase) -> [Swift.String : Any]?
  public func toJSONString() -> Swift.String?
}
extension Swift.Decodable {
  public static func fromJsonWithSameTypeName(bundle: Foundation.Bundle) throws -> Self
  public static func fromJson(named name: Swift.String, bundle: Foundation.Bundle) throws -> Self
  public static func fromJSON(jsonData: Foundation.Data) throws -> Self
}
extension Swift.Encodable {
  @discardableResult
  public func saveToJsonFile(_ filename: Swift.String, bundle: Foundation.Bundle = .main, storageType: WorkoutsPlayerCoreInternal.StorageType = .cache) throws -> Foundation.URL
}
extension Foundation.Data {
  @discardableResult
  public func saveToFile(_ filename: Swift.String, bundle: Foundation.Bundle = .main, storageType: WorkoutsPlayerCoreInternal.StorageType = .cache) throws -> Foundation.URL
}
public struct FileMissing : Swift.Error, Swift.CustomStringConvertible {
  public let path: Foundation.URL
  public var description: Swift.String {
    get
  }
}
extension Swift.Decodable {
  public static func fromJsonFile(_ filename: Swift.String, bundle: Foundation.Bundle = .main, storageType: WorkoutsPlayerCoreInternal.StorageType = .cache) throws -> Self
}
public class FrameworkDummy {
  public init()
  @objc deinit
}
public struct Future<FutureElement, Failure> where Failure : Swift.Error {
  public typealias Callback = (Swift.Result<FutureElement, Failure>) -> Swift.Void
  public let future: (@escaping WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Callback) -> WorkoutsPlayerCoreInternal.Disposable
  public init(future: @escaping (@escaping WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Callback) -> WorkoutsPlayerCoreInternal.Disposable)
}
extension WorkoutsPlayerCoreInternal.Future {
  public func mapResult<Output>(_ transform: @escaping (Swift.Result<WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element, Failure>) -> Swift.Result<Output, Failure>) -> WorkoutsPlayerCoreInternal.Future<Output, Failure>
  public func map<Output>(_ transform: @escaping (WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element) -> Output) -> WorkoutsPlayerCoreInternal.Future<Output, Failure>
  public func flatMap<Output>(_ transform: @escaping (WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element) -> WorkoutsPlayerCoreInternal.Future<Output, Failure>) -> WorkoutsPlayerCoreInternal.Future<Output, Failure>
}
extension WorkoutsPlayerCoreInternal.Future {
  public func `do`(_ sideEffect: @escaping (WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element) -> Swift.Void) -> WorkoutsPlayerCoreInternal.Future<WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element, Failure>
  public func `do`(onSuccess: WorkoutsPlayerCoreInternal.Handler<WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element>? = nil, onError: WorkoutsPlayerCoreInternal.Handler<Failure>? = nil) -> WorkoutsPlayerCoreInternal.Future<WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element, Failure>
  public func doResult(_ sideEffect: @escaping (Swift.Result<WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element, Failure>) -> Swift.Void) -> WorkoutsPlayerCoreInternal.Future<WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element, Failure>
  public func debug(_ string: Swift.String) -> WorkoutsPlayerCoreInternal.Future<WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element, Failure>
  public func debug(_ generator: @escaping (WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element) -> Swift.String, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) -> WorkoutsPlayerCoreInternal.Future<WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element, Failure>
}
extension WorkoutsPlayerCoreInternal.Future {
  public static var never: WorkoutsPlayerCoreInternal.Future<FutureElement, Failure> {
    get
  }
}
public protocol ImageCache {
  func add(image: UIKit.UIImage, withIdentifier identifier: Swift.String)
  func cachedImage(withIdentifier identifier: Swift.String) -> UIKit.UIImage?
  func removeAllImages()
}
public struct NoImageCache : WorkoutsPlayerCoreInternal.ImageCache {
  public init()
  public func add(image _: UIKit.UIImage, withIdentifier _: Swift.String)
  public func cachedImage(withIdentifier _: Swift.String) -> UIKit.UIImage?
  public func removeAllImages()
}
public typealias ImageDownloaderResultHandler = (Swift.Result<UIKit.UIImage, WorkoutsPlayerCoreInternal.ImageDownloaderError>) -> Swift.Void
public class ImageDownloader {
  public init()
  public func downloadImage(from url: Foundation.URL, imageCache: WorkoutsPlayerCoreInternal.ImageCache, handler: @escaping WorkoutsPlayerCoreInternal.ImageDownloaderResultHandler)
  public func downloadImage(from url: Foundation.URL, imageCache: WorkoutsPlayerCoreInternal.ImageCache, downsamplingTo downsamplingSize: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat, handler: @escaping WorkoutsPlayerCoreInternal.ImageDownloaderResultHandler)
  public func cancelDownloading()
  @objc deinit
}
public enum ImageDownloaderError : Foundation.LocalizedError, Foundation.CustomNSError {
  case invalidResponse
  case invalidMimeType
  case noData
  case error(Swift.Error)
  case errorWithInfo(Swift.Error, Swift.String)
  public var localizedDescription: Swift.String? {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public func expected200to300(_ code: Swift.Int) -> Swift.Bool
public typealias LocalizedMessages = WorkoutsPlayerCoreInternal.Localizations.Messages
public typealias LocalizedErrors = WorkoutsPlayerCoreInternal.Localizations.Errors
public typealias StringGenerator<T> = (T) -> Swift.String
public enum Localizations {
  public enum Errors {
    public static var login: (Swift.Error) -> Swift.String
    public static var signingAndFetchingWorkout: (Swift.Error) -> Swift.String
  }
  public enum Messages {
    public static var signedInUser: (Swift.String) -> Swift.String
    public static var workoutFetched: (Swift.String) -> Swift.String
  }
}
extension MediaPlayer.MPVolumeView {
  @_Concurrency.MainActor(unsafe) public static var volume: Swift.Float? {
    get
    set
  }
}
@objc public class MuuvBlock : ObjectiveC.NSObject, Swift.Codable {
  public var blockId: Swift.Int?
  public var canBeReplaced: Swift.Bool
  public var className: Swift.String?
  public var completedInt: Swift.Int64?
  public var demoDash: Swift.String?
  public var demoHls: Swift.String?
  public var demoMp4: Swift.String?
  public var durationSeconds: Swift.Int?
  public var id: Swift.String?
  public var isDownAvailable: Swift.Bool?
  public var isEmom: Swift.Bool?
  public var isSkipped: Swift.Bool?
  public var isUpAvailable: Swift.Bool?
  public var level: Swift.Int?
  public var load: Swift.String?
  public var movement: Swift.String?
  public var name: Swift.String?
  public var position: Swift.Int?
  public var poster: Swift.String?
  public var reps: Swift.Int?
  public var rest: Swift.Int?
  public var setName: Swift.String?
  public var sets: Swift.Int?
  public var skippedAt: Swift.Int?
  public var speed: Swift.String?
  public var technical: Swift.String?
  public var thumbnail: Swift.String?
  public var video1Mp4: Swift.String?
  public var video1Hls: Swift.String?
  public var video2Mp4: Swift.String?
  public var video2Hls: Swift.String?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers public class MuuvSDK : ObjectiveC.NSObject {
  public static var resourcesBundle: Foundation.Bundle {
    get
  }
  public func tearDown()
  public var currentEngine: WorkoutsPlayerCoreInternal.AudioCoachingEngine? {
    get
  }
  @discardableResult
  public func createAudioCoachingEngine(workout: WorkoutsPlayerCoreInternal.Workout, delegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDelegate? = nil, downloadingDelegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDownloadingDelegate? = nil) -> WorkoutsPlayerCoreInternal.AudioCoachingEngine
  @objc override dynamic public init()
  @objc deinit
}
extension Foundation.Bundle {
  public static var muuvSDK: Foundation.Bundle {
    get
  }
}
@objc public class MuuvSDKEngineIntegrationBuilder : ObjectiveC.NSObject {
  public var toolbox: WorkoutsPlayerCoreInternal.MuuvSDKTools? {
    get
  }
  public var engine: WorkoutsPlayerCoreInternal.AudioCoachingEngine {
    get
  }
  public init(toolbox: WorkoutsPlayerCoreInternal.MuuvSDKTools?, workout: WorkoutsPlayerCoreInternal.Workout, engineDelegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDelegate?, downloadingDelegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDownloadingDelegate?)
  public func tearDown()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class MuuvSDKTools : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
public struct MuuvStream : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct MuuvEquipment : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct MuuvTag : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers public class MuuvWorkout : ObjectiveC.NSObject, Swift.Codable {
  public var averageHeartRate: Swift.Int?
  public var appliedIntensity: Swift.Int?
  public var appliedMets: Swift.Int?
  public var caloriesBurned: Swift.Int?
  public var className: Swift.String?
  public var coachId: Swift.String?
  public var completedInt: Swift.Int?
  public var completedSeconds: Swift.Int?
  public var createdInt: Swift.Int?
  public var durationSeconds: Swift.Int?
  public var equipment: Swift.String?
  public var id: Swift.Int?
  public var intensity: Swift.Int?
  public var intensityMod: Swift.String?
  public var isCompleted: Swift.Bool?
  public var isLiked: Swift.Bool?
  public var isStarted: Swift.Bool?
  public var sections: [WorkoutsPlayerCoreInternal.MuuvWorkoutSection]?
  public var reason: Swift.String?
  public var startedInt: Swift.Int?
  public var stream: WorkoutsPlayerCoreInternal.MuuvStream?
  public var streamId: Swift.String?
  public var streamIdent: Swift.String?
  public var totalReps: Swift.Int?
  public var totalSets: Swift.Int?
  public var userId: Swift.String?
  public var url: Swift.String?
  public var uuid: Foundation.UUID?
  public var workoutFeedback: Swift.String?
  public var workoutType: Swift.String?
  public func caloriesCounter(userWeight: Swift.Double, duration: Foundation.TimeInterval) -> Swift.Double?
  @objc override dynamic public init()
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension WorkoutsPlayerCoreInternal.MuuvWorkout : WorkoutsPlayerCoreInternal.PlayableWorkout {
  public var identifier: Swift.Int {
    get
  }
  public var title: Swift.String {
    get
  }
  public var workoutSections: [WorkoutsPlayerCoreInternal.PlayableWorkoutSection] {
    get
  }
  public var type: Swift.String? {
    get
  }
  public var durationInSeconds: Foundation.TimeInterval {
    get
  }
  public func isBlockAvailableAt(sectionIndex: Swift.Int, blockIndex: Swift.Int) -> Swift.Bool
}
extension WorkoutsPlayerCoreInternal.MuuvWorkoutSection : WorkoutsPlayerCoreInternal.PlayableWorkoutSection {
  public var blocks: [WorkoutsPlayerCoreInternal.PlayableWorkoutBlock] {
    get
  }
  public var numberOfBlocks: Swift.Int {
    get
  }
  public func block(atIndex: Swift.Int, intensity: Swift.Int) -> WorkoutsPlayerCoreInternal.PlayableBlock?
  public var title: Swift.String {
    get
  }
}
extension WorkoutsPlayerCoreInternal.MuuvWorkoutBlock : WorkoutsPlayerCoreInternal.PlayableWorkoutBlock {
  public var intensityBlocks: [WorkoutsPlayerCoreInternal.PlayableBlock] {
    get
  }
  public func block(intensity: Swift.Int) -> WorkoutsPlayerCoreInternal.PlayableBlock?
}
extension WorkoutsPlayerCoreInternal.MuuvBlock : WorkoutsPlayerCoreInternal.PlayableBlock {
  public var identifier: Swift.String {
    get
  }
  public var replacementBlock: WorkoutsPlayerCoreInternal.PlayableBlock? {
    get
  }
  public var intensity: Swift.Int {
    get
  }
  public var isEveryMinuteOnTheMinute: Swift.Bool {
    get
  }
  public var numberOfSets: Swift.Int {
    get
  }
  public var repetitions: Swift.Int {
    get
  }
  public var restTimeInSeconds: Foundation.TimeInterval {
    get
  }
  public var durationToShow: Swift.String? {
    get
  }
  public var title: Swift.String {
    get
  }
  public var videoURL: Foundation.URL? {
    get
  }
  public var downloadableURL: Foundation.URL? {
    get
  }
}
@objc public class MuuvWorkoutBlock : ObjectiveC.NSObject, Swift.Codable {
  public var level: Swift.Int
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc public class MuuvWorkoutSection : ObjectiveC.NSObject, Swift.Codable {
  public var id: Swift.String?
  public var bucketId: Swift.String?
  public var workoutBlocks: [WorkoutsPlayerCoreInternal.MuuvWorkoutBlock]
  public var completedInt: Swift.Int?
  public var familyId: Swift.String?
  public var isReplaceable: Swift.Bool?
  public var level: Swift.Int?
  public var position: Swift.Int?
  public var setName: Swift.String?
  public var setId: Swift.String?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public protocol NoParamNotificable {
  var id: Swift.String { get }
  func post()
  func addListener(handler: @escaping WorkoutsPlayerCoreInternal.Action) -> WorkoutsPlayerCoreInternal.Disposable
}
extension Foundation.NSNotification.Name : WorkoutsPlayerCoreInternal.NoParamNotificable {
  public func post()
  public func addListener(handler: @escaping (Foundation.Notification) -> Swift.Void) -> WorkoutsPlayerCoreInternal.Disposable
  public func addListener(handler: @escaping WorkoutsPlayerCoreInternal.Action) -> WorkoutsPlayerCoreInternal.Disposable
}
extension WorkoutsPlayerCoreInternal.NoParamNotificable {
  public var name: Foundation.Notification.Name {
    get
  }
  public func post()
  public func addListener<A>(weak obj: A, handler: @escaping (A) -> () -> Swift.Void) -> WorkoutsPlayerCoreInternal.Disposable where A : AnyObject
  public func addListener(handler: @escaping (Foundation.Notification, Self) -> Swift.Void) -> WorkoutsPlayerCoreInternal.Disposable
  public func addListener(handler: @escaping (Foundation.Notification) -> Swift.Void) -> WorkoutsPlayerCoreInternal.Disposable
  public func addListener(handler: @escaping WorkoutsPlayerCoreInternal.Action) -> WorkoutsPlayerCoreInternal.Disposable
}
public protocol Notificable {
  associatedtype ParameterType
  var id: Swift.String { get }
  func post(_ parameter: Self.ParameterType)
  func addListener(handler: @escaping WorkoutsPlayerCoreInternal.Handler<Self.ParameterType>) -> WorkoutsPlayerCoreInternal.Disposable
}
extension WorkoutsPlayerCoreInternal.Notificable {
  public var name: Foundation.Notification.Name {
    get
  }
  public func post(_ parameter: Self.ParameterType)
  public func addListener(handler: @escaping WorkoutsPlayerCoreInternal.Handler<Self.ParameterType>) -> WorkoutsPlayerCoreInternal.Disposable
  public func addListener(handler: @escaping (Foundation.Notification, Self.ParameterType) -> Swift.Void) -> WorkoutsPlayerCoreInternal.Disposable
  public func addNoParamsListener<T>(weak object: T, _ handler: @escaping (T) -> () -> Swift.Void) -> WorkoutsPlayerCoreInternal.Disposable where T : AnyObject
  public func addListener<T>(weak object: T, handler: @escaping (T) -> (Self.ParameterType) -> Swift.Void) -> WorkoutsPlayerCoreInternal.Disposable where T : AnyObject
  public func addListener<T>(weak object: T, handler: @escaping (T, Self.ParameterType) -> Swift.Void) -> WorkoutsPlayerCoreInternal.Disposable where T : AnyObject
}
public struct GenNotification<T> : WorkoutsPlayerCoreInternal.Notificable {
  public typealias ParameterType = T
  public var id: Swift.String {
    get
  }
  public init(id: Swift.String)
}
extension WorkoutsPlayerCoreInternal.NoParamNotificable where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var id: Swift.String {
    get
  }
}
extension WorkoutsPlayerCoreInternal.Notificable where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var id: Swift.String {
    get
  }
}
extension WorkoutsPlayerCoreInternal.NoParamNotificable where Self : Swift.RawRepresentable, Self.RawValue == Swift.Int {
  public var id: Swift.String {
    get
  }
}
extension WorkoutsPlayerCoreInternal.Notificable where Self : Swift.RawRepresentable, Self.RawValue == Swift.Int {
  public var id: Swift.String {
    get
  }
}
public struct NowPlayableStaticMetadata : Swift.Equatable {
  public init(assetURL: Foundation.URL?, mediaType: MediaPlayer.MPNowPlayingInfoMediaType, isLiveStream: Swift.Bool, title: Swift.String?, artist: Swift.String?, image: UIKit.UIImage?, albumArtist: Swift.String?, albumTitle: Swift.String?)
  public static func == (a: WorkoutsPlayerCoreInternal.NowPlayableStaticMetadata, b: WorkoutsPlayerCoreInternal.NowPlayableStaticMetadata) -> Swift.Bool
}
public struct NowPlayableDynamicMetadata : Swift.Equatable {
  public init(rate: Swift.Float, position: Swift.Float, duration: Swift.Float, currentLanguageOptions: [MediaPlayer.MPNowPlayingInfoLanguageOption], availableLanguageOptionGroups: [MediaPlayer.MPNowPlayingInfoLanguageOptionGroup], isNextSupported: Swift.Bool, isPrevSupported: Swift.Bool, isPlaying: Swift.Bool, queueIndex: Swift.Int, queueCount: Swift.Int)
  public static func == (a: WorkoutsPlayerCoreInternal.NowPlayableDynamicMetadata, b: WorkoutsPlayerCoreInternal.NowPlayableDynamicMetadata) -> Swift.Bool
}
public protocol PlayableWorkout {
  var identifier: Swift.Int { get }
  var title: Swift.String { get }
  var workoutSections: [WorkoutsPlayerCoreInternal.PlayableWorkoutSection] { get }
  var durationInSeconds: Foundation.TimeInterval { get }
  var type: Swift.String? { get }
}
public protocol PlayableWorkoutSection {
  var title: Swift.String { get }
  var blocks: [WorkoutsPlayerCoreInternal.PlayableWorkoutBlock] { get }
  var numberOfBlocks: Swift.Int { get }
  func block(atIndex: Swift.Int, intensity: Swift.Int) -> WorkoutsPlayerCoreInternal.PlayableBlock?
}
public protocol PlayableWorkoutBlock {
  var intensityBlocks: [WorkoutsPlayerCoreInternal.PlayableBlock] { get }
  var level: Swift.Int { get }
  func block(intensity: Swift.Int) -> WorkoutsPlayerCoreInternal.PlayableBlock?
}
public protocol PlayableBlock {
  var identifier: Swift.String { get }
  var downloadableURL: Foundation.URL? { get }
  var intensity: Swift.Int { get }
  var isEveryMinuteOnTheMinute: Swift.Bool { get }
  var canBeReplaced: Swift.Bool { get }
  var numberOfSets: Swift.Int { get }
  var repetitions: Swift.Int { get }
  var restTimeInSeconds: Foundation.TimeInterval { get }
  var title: Swift.String { get }
  var durationToShow: Swift.String? { get }
  var setName: Swift.String? { get }
  var videoURL: Foundation.URL? { get }
}
extension WorkoutsPlayerCoreInternal.PlayableWorkout {
  public func firstBlockIn(section: Swift.Int, offset: Swift.Int) -> WorkoutsPlayerCoreInternal.PlayableWorkoutBlock?
  public func lastBlockIn(section: Swift.Int, offset: Swift.Int) -> WorkoutsPlayerCoreInternal.PlayableWorkoutBlock?
}
public enum InterruptionNotification : Swift.Int, WorkoutsPlayerCoreInternal.NoParamNotificable {
  case audioSessionInterruptionDidBegin
  case audioSessionInterruptionDidEndAndPlaybackShouldResume
  case audioSessionInterruptionDidEndAndPlaybackShouldNotResume
  case phoneCallDidDisconnect
  case phoneCallDidStartDialing
  case phoneCallDidReceiveIncoming
  case phoneCallDidConnect
  case testPause
  case testResume
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol Promise {
  associatedtype Element
  associatedtype Failure : Swift.Error
  typealias Callback = (Swift.Result<Self.Element, Self.Failure>) -> Swift.Void
  func subscribe(_ observer: WorkoutsPlayerCoreInternal.Observer<Self.Element, Self.Failure>) -> WorkoutsPlayerCoreInternal.Disposable
}
extension WorkoutsPlayerCoreInternal.Future : WorkoutsPlayerCoreInternal.Promise {
  public typealias Element = FutureElement
  public typealias SomeFailure = Failure
  public func subscribe(_ observer: WorkoutsPlayerCoreInternal.Observer<WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element, WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.SomeFailure>) -> WorkoutsPlayerCoreInternal.Disposable
  public func subscribe() -> WorkoutsPlayerCoreInternal.Disposable
  public func subscribe(_ callback: @escaping (Swift.Result<WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element, WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.SomeFailure>) -> Swift.Void) -> WorkoutsPlayerCoreInternal.Disposable
  public func subscribe(onSuccess: WorkoutsPlayerCoreInternal.Handler<WorkoutsPlayerCoreInternal.Future<FutureElement, Failure>.Element>? = nil, onError: WorkoutsPlayerCoreInternal.Handler<Swift.Error>? = nil) -> WorkoutsPlayerCoreInternal.Disposable
}
public struct Observer<Element, Failure> where Failure : Swift.Error {
  public func on(result: Swift.Result<Element, Failure>)
}
@objc public class ReactiveAudioSnippet : ObjectiveC.NSObject, Swift.Codable {
  public var queue: Swift.String
  public var mp3: Swift.String
  public var durationMs: Swift.Double
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case queue
    case mp3
    case durationMs
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  required public init(from decoder: Swift.Decoder) throws
  public var duration: Foundation.TimeInterval {
    get
  }
  public init(queue: Swift.String, mp3: Swift.String, durationMs: Swift.Double)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
@objc public class CancelReactiveAudioInfo : ObjectiveC.NSObject, Swift.Codable {
  public var cancel: Swift.String
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc public class DismissReactiveAudioInfo : ObjectiveC.NSObject, Swift.Codable {
  public var dismiss: Swift.String
  public init(dismiss: Swift.String)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension Swift.Result {
  public var error: Swift.Error? {
    get
  }
  public var isSuccess: Swift.Bool {
    get
  }
  public var isFailure: Swift.Bool {
    get
  }
}
extension Swift.Sequence {
  public func sorted(by keyPath: Swift.KeyPath<Self.Element, some Comparable>) -> [Self.Element]
}
public enum WorkoutBlockDownloadStatus {
  case notStarted
  case progress(WorkoutsPlayerCoreInternal.BatchDownload)
  case finished(WorkoutsPlayerCoreInternal.Timeline)
  case nothingToDownload
  case failed(Swift.Error)
  public var isFinished: Swift.Bool {
    get
  }
  public var isFailed: Swift.Bool {
    get
  }
  public var bytesToDownload: Swift.Int64? {
    get
  }
  public var bytesDownloaded: Swift.Int64? {
    get
  }
}
public enum SharedResource {
  public static let buttonThumbUpImage: UIKit.UIImage?
}
public struct SmartWorkoutsConfig : Swift.Codable, Swift.Equatable {
  public let types: [WorkoutsPlayerCoreInternal.SmartWorkoutType]
  public static func == (a: WorkoutsPlayerCoreInternal.SmartWorkoutsConfig, b: WorkoutsPlayerCoreInternal.SmartWorkoutsConfig) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct SmartWorkoutType : Swift.Codable, Swift.Equatable {
  public let description: Swift.String
  public let icon: Swift.String
  public let name: Swift.String
  public let tiles: [WorkoutsPlayerCoreInternal.SmartWorkoutTile]
  public let isNew: Swift.Bool?
  public let ident: Swift.String
  public static func == (a: WorkoutsPlayerCoreInternal.SmartWorkoutType, b: WorkoutsPlayerCoreInternal.SmartWorkoutType) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct SmartWorkoutTile : Swift.Codable, Swift.Equatable {
  public let coaches: [WorkoutsPlayerCoreInternal.SmartWorkoutCoach]
  public let durationSeconds: Foundation.TimeInterval?
  public let equipment: [WorkoutsPlayerCoreInternal.SmartWorkoutEquipment]
  public let icon: Swift.String
  public let name: Swift.String
  public let streamId: Swift.Int?
  public let isRemovingVariousCoaches: Swift.Bool?
  public static func == (a: WorkoutsPlayerCoreInternal.SmartWorkoutTile, b: WorkoutsPlayerCoreInternal.SmartWorkoutTile) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct SmartWorkoutEquipment : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public let id: Swift.Int
  public let name: Swift.String
  public static func == (a: WorkoutsPlayerCoreInternal.SmartWorkoutEquipment, b: WorkoutsPlayerCoreInternal.SmartWorkoutEquipment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct SmartWorkoutCoach : Swift.Codable, Swift.Equatable {
  public let id: Swift.Int
  public let name: Swift.String
  public let style: Swift.String
  public let poster: Swift.String?
  public let thumbnail: Swift.String?
  public static var various: WorkoutsPlayerCoreInternal.SmartWorkoutCoach {
    get
  }
  public static func == (a: WorkoutsPlayerCoreInternal.SmartWorkoutCoach, b: WorkoutsPlayerCoreInternal.SmartWorkoutCoach) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension WorkoutsPlayerCoreInternal.SmartWorkoutsConfig {
  public var firstTile: WorkoutsPlayerCoreInternal.SmartWorkoutTile? {
    get
  }
}
public enum SmartWorkoutIntensity : Swift.String, Swift.Codable, Swift.CaseIterable, Swift.Equatable {
  case easier
  case same
  case harder
  public init?(rawValue: Swift.String)
  public typealias AllCases = [WorkoutsPlayerCoreInternal.SmartWorkoutIntensity]
  public typealias RawValue = Swift.String
  public static var allCases: [WorkoutsPlayerCoreInternal.SmartWorkoutIntensity] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public class StandaloneAudioCoachingEngine : WorkoutsPlayerCoreInternal.AudioCoachingEngine {
  weak public var delegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDelegate?
  weak public var downloadingDelegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDownloadingDelegate?
  weak public var timerDelegate: WorkoutsPlayerCoreInternal.WorkoutPlayerTimerDelegate?
  public var isPlaying: Swift.Bool
  public var isStarted: Swift.Bool
  public var avgHeartRate: Swift.Int
  public var heartRate: Swift.Int
  public var calories: Swift.Int
  public var userWeight: Swift.Int
  public var didReceiveInfoFromWatch: Swift.Bool
  public var isWorkoutFinished: Swift.Bool {
    get
  }
  public var workout: WorkoutsPlayerCoreInternal.Workout {
    get
  }
  required public init(workout: WorkoutsPlayerCoreInternal.Workout, delegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDelegate?, downloadingDelegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineDownloadingDelegate?)
  public var controlsDelegate: WorkoutsPlayerCoreInternal.AudioCoachingEngineControlsDelegate {
    get
  }
  public var volume: Swift.Float {
    get
    set
  }
  public var coachVolume: Swift.Float {
    get
    set
  }
  public var isFormEnabled: Swift.Bool {
    get
    set
  }
  public var isMotivationEnabled: Swift.Bool {
    get
    set
  }
  public var isPacingEnabled: Swift.Bool {
    get
    set
  }
  public var isDirectionEnabled: Swift.Bool {
    get
    set
  }
  public var isBumpsEnabled: Swift.Bool {
    get
    set
  }
  public var isPaused: Swift.Bool {
    get
  }
  public var elapsedTime: Foundation.TimeInterval {
    get
  }
  public var currentBlock: WorkoutsPlayerCoreInternal.WorkoutBlock? {
    get
  }
  public var currentBlockElapsedTime: Foundation.TimeInterval {
    get
  }
  public var bytesToDownload: Swift.Int64 {
    get
  }
  public var bytesDownloaded: Swift.Int64 {
    get
  }
  public var currentBlockProgressFloat: Swift.Float {
    get
  }
  public var currentBlockProgress: Swift.Float? {
    get
  }
  @objc deinit
}
extension WorkoutsPlayerCoreInternal.StandaloneAudioCoachingEngine {
  public func downloadStatusOf(block: WorkoutsPlayerCoreInternal.WorkoutBlock) -> WorkoutsPlayerCoreInternal.WorkoutBlockDownloadStatus?
  @objc dynamic public func canDecreaseIntensityOf(block: WorkoutsPlayerCoreInternal.WorkoutBlock?) -> Swift.Bool
  @objc dynamic public func canIncreaseIntensityOf(block: WorkoutsPlayerCoreInternal.WorkoutBlock?) -> Swift.Bool
  @objc dynamic public func canReplace(block: WorkoutsPlayerCoreInternal.WorkoutBlock?) -> Swift.Bool
  @objc dynamic public func canSkip(block: WorkoutsPlayerCoreInternal.WorkoutBlock?) -> Swift.Bool
  @objc dynamic public func canMarkDone(block: WorkoutsPlayerCoreInternal.WorkoutBlock?) -> Swift.Bool
  @objc dynamic public var canStartWorkout: Swift.Bool {
    @objc get
  }
  @objc dynamic public var canPauseWorkout: Swift.Bool {
    @objc get
  }
  @objc dynamic public var canResumeWorkout: Swift.Bool {
    @objc get
  }
  @objc dynamic public var canFinishWorkout: Swift.Bool {
    @objc get
  }
  @objc dynamic public var canDiscardWorkout: Swift.Bool {
    @objc get
  }
  @objc dynamic public var canDecreaseIntensity: Swift.Bool {
    @objc get
  }
  @objc dynamic public var canIncreaseIntensity: Swift.Bool {
    @objc get
  }
  @objc dynamic public var canReplaceBlock: Swift.Bool {
    @objc get
  }
  @objc dynamic public var canSkipBlock: Swift.Bool {
    @objc get
  }
  @objc dynamic public var canMarkBlockAsDone: Swift.Bool {
    @objc get
  }
}
extension WorkoutsPlayerCoreInternal.StandaloneAudioCoachingEngine {
  public func setCurrentBlock(_ block: WorkoutsPlayerCoreInternal.WorkoutBlock?, isAlreadySelected: Swift.Bool = false)
  public func start()
  public func pause()
  public func resume()
  public func increaseIntensity()
  public func decreaseIntensity()
  public func skipBlock()
  public func markBlockDone()
  public func replaceBlock()
  public func finish()
  public func dismissBump()
  public func discard()
  public func stopPlayingCurrentBlock()
  public func cancelReactiveAudio(info: WorkoutsPlayerCoreInternal.CancelReactiveAudioInfo)
  public func dismissReactiveAudio(info: WorkoutsPlayerCoreInternal.DismissReactiveAudioInfo)
  public func playWhenIsPossible(reactiveAudioSnippet: WorkoutsPlayerCoreInternal.ReactiveAudioSnippet)
}
extension WorkoutsPlayerCoreInternal.StandaloneAudioCoachingEngine : WorkoutsPlayerCoreInternal.WorkoutPlayerTimerDelegate {
  public func timer(listPlayerTimer: WorkoutsPlayerCoreInternal.WorkoutPlayerTimer, didUpdate elapsedTime: Foundation.TimeInterval)
}
public enum StorageType {
  case cache
  case documents
  public static func == (a: WorkoutsPlayerCoreInternal.StorageType, b: WorkoutsPlayerCoreInternal.StorageType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Stream : Swift.Codable {
  public let id: Swift.Int
  public let name: Swift.String
  public let poster: Swift.String?
  public let thumbnail: Swift.String?
  public let isManual: Swift.Bool?
  public let description: Swift.String?
  public let className: Swift.String?
  public let durationSeconds: Swift.Int?
  public let isPublished: Swift.Bool?
  public let publishedInt: Swift.Int64?
  public let publisher: Swift.String?
  public let isClub: Swift.Bool?
  public let isFixedDuration: Swift.Bool?
  public let isVideo: Swift.Bool?
  public let isList: Swift.Bool?
  public let tags: [WorkoutsPlayerCoreInternal.Tag]?
  public let clubFullAddress: Swift.String?
  public let equipmentRequired: [Swift.String]?
  public let appliedIntensity: Swift.Int?
  public var isDailyChallenge: Swift.Bool?
  public let bodySegmentUrl: Swift.String?
  public let permissions: [Swift.String]?
  public let isRecommender: Swift.Bool?
  public let isRecommenderDefault: Swift.Bool?
  public let modelName: Swift.String?
  public let hkWorkoutActivity: Swift.String?
  public var isPremium: Swift.Bool {
    get
  }
  public var isStatic: Swift.Bool {
    get
  }
  public var isEquipmentRequired: Swift.Bool {
    get
  }
  public init(id: Swift.Int, name: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public init(id: Swift.Int, name: Swift.String, poster: Swift.String?, thumbnail: Swift.String?, isManual: Swift.Bool?, description: Swift.String?, className: Swift.String?, durationSeconds: Swift.Int?, isPublished: Swift.Bool?, publishedInt: Swift.Int64?, publisher: Swift.String?, isClub: Swift.Bool?, isFixedDuration: Swift.Bool?, isVideo: Swift.Bool?, isList: Swift.Bool?, tags: [WorkoutsPlayerCoreInternal.Tag]?, clubFullAddress: Swift.String?, equipmentRequired: [Swift.String]?, appliedIntensity: Swift.Int?, isDailyChallenge: Swift.Bool?, bodySegmentUrl: Swift.String?, permissions: [Swift.String]?, internalIsPremium: Swift.Bool?, internalIsStatic: Swift.Bool?, isRecommender: Swift.Bool?, isRecommenderDefault: Swift.Bool?, modelName: Swift.String?, hkWorkoutActivity: Swift.String?)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Tag : Swift.Codable, Swift.Equatable {
  public let id: Swift.Int
  public let tagGroupId: Swift.Int?
  public let name: Swift.String?
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case id
    case name
    case tagGroupId
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public var isBodyPart: Swift.Bool {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: WorkoutsPlayerCoreInternal.Tag, b: WorkoutsPlayerCoreInternal.Tag) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
}
extension WorkoutsPlayerCoreInternal.Stream {
  public func minutes() -> Swift.Float
  public func minutesText() -> Swift.String
}
extension Swift.String {
  public func convertToDictionary() -> [Swift.String : Any]?
  public func replacingOccurrences(of strings: [Swift.String], with newValue: Swift.String) -> Swift.String
  public var isValidEmail: Swift.Bool {
    get
  }
  public static func minutesAndSeconds(from seconds: Swift.Int) -> Swift.String?
  public func convertToPhoneNumber() -> Swift.String?
}
public protocol StringFailableDecodable : Swift.Decodable {
  static func decodeUsing<K>(container: Swift.KeyedDecodingContainer<K>, key: K) throws -> Self? where K : Swift.CodingKey
  init?(_ string: Swift.String)
}
extension WorkoutsPlayerCoreInternal.StringFailableDecodable {
  public static func decodeUsing<K>(container: Swift.KeyedDecodingContainer<K>, key: K) throws -> Self? where K : Swift.CodingKey
}
extension Swift.Int : WorkoutsPlayerCoreInternal.StringFailableDecodable {
}
extension Swift.Int64 : WorkoutsPlayerCoreInternal.StringFailableDecodable {
}
extension Swift.Double : WorkoutsPlayerCoreInternal.StringFailableDecodable {
}
extension Swift.Float : WorkoutsPlayerCoreInternal.StringFailableDecodable {
}
extension Swift.UInt : WorkoutsPlayerCoreInternal.StringFailableDecodable {
}
extension Swift.KeyedDecodingContainer {
  public func decodeFailingToString<T>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> T where T : WorkoutsPlayerCoreInternal.StringFailableDecodable
  public func decodeFailingToStringIfPresent<T>(_ type: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) -> T? where T : WorkoutsPlayerCoreInternal.StringFailableDecodable
}
@_hasMissingDesignatedInitializers public class Ticker {
  convenience public init(tickInterval: Dispatch.DispatchTimeInterval, callback: @escaping WorkoutsPlayerCoreInternal.Action)
  @objc deinit
  public func startTicking()
  public func stopTicking()
}
extension WorkoutsPlayerCoreInternal.Ticker : WorkoutsPlayerCoreInternal.Disposable {
  public func dispose()
}
extension Foundation.Timer : WorkoutsPlayerCoreInternal.Disposable {
  public func dispose()
}
extension Dispatch.DispatchTimeInterval {
  public var seconds: Foundation.TimeInterval {
    get
  }
}
public class Timeline {
  public var events: [WorkoutsPlayerCoreInternal.TimelineEvent] {
    get
  }
  public init(events: [WorkoutsPlayerCoreInternal.TimelineEvent])
  public func indexOf(event: WorkoutsPlayerCoreInternal.TimelineEvent) -> Swift.Int?
  public var isStarted: Swift.Bool {
    get
  }
  public func isLast(_ event: WorkoutsPlayerCoreInternal.TimelineEvent) -> Swift.Bool
  public func append(event: WorkoutsPlayerCoreInternal.TimelineEvent)
  public func canPlayNewTimeline(for duration: Swift.Float) -> Swift.Bool?
  public var isTimelineEmpty: Swift.Bool {
    get
  }
  public func canPlayNow(duration: Swift.Float) -> Swift.Bool?
  public func addToPlay(bumpTimelineEvent: WorkoutsPlayerCoreInternal.TimelineEvent, duration: Swift.Float)
  public func addToPlay(timelineEvent: WorkoutsPlayerCoreInternal.TimelineEvent, duration: Swift.Float)
  public var hasBumpsToPlay: Swift.Bool {
    get
  }
  public var hasReactiveAudioSnippetToPlay: Swift.Bool {
    get
  }
  public var hasPendingEventsToPlay: Swift.Bool {
    get
  }
  @objc deinit
}
public struct TimelineEvent : Swift.Equatable {
  public var time: Foundation.TimeInterval
  public var duration: Foundation.TimeInterval
  public var url: Foundation.URL
  public var localUrl: Foundation.URL?
  public var image: UIKit.UIImage?
  public var title: Swift.String?
  public var isBumpEvent: Swift.Bool
  public var isReactiveAudio: Swift.Bool
  public init(time: Foundation.TimeInterval, duration: Foundation.TimeInterval, url: Foundation.URL, downloadedURL: Foundation.URL? = nil, image: UIKit.UIImage? = nil, title: Swift.String? = nil, isBumpEvent: Swift.Bool = false, isReactiveAudio: Swift.Bool = false)
  public mutating func change(time: Foundation.TimeInterval, isBumpEvent: Swift.Bool, isReactiveAudio: Swift.Bool)
  public var endTime: Foundation.TimeInterval {
    get
  }
  public static func == (a: WorkoutsPlayerCoreInternal.TimelineEvent, b: WorkoutsPlayerCoreInternal.TimelineEvent) -> Swift.Bool
}
extension WorkoutsPlayerCoreInternal.TimelineEvent : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol TimelineDelegate : AnyObject {
  func timeline(_ timeline: WorkoutsPlayerCoreInternal.Timeline, didFire event: WorkoutsPlayerCoreInternal.TimelineEvent)
  func dismissCurrentTimeline()
}
extension WorkoutsPlayerCoreInternal.Timeline : Swift.Equatable {
  public static func == (lhs: WorkoutsPlayerCoreInternal.Timeline, rhs: WorkoutsPlayerCoreInternal.Timeline) -> Swift.Bool
}
public class TimelineDownloader {
  public typealias Progress = [Foundation.URL : Swift.Float?]
  public init(timeline: WorkoutsPlayerCoreInternal.Timeline, downloader: WorkoutsPlayerCoreInternal.Downloader = .backgroundShared)
  public func download(retryCount: Swift.Int = 3, onUpdate: WorkoutsPlayerCoreInternal.Handler<WorkoutsPlayerCoreInternal.TimelineDownloader.Progress>? = nil, onBatchDownloadUpdate: WorkoutsPlayerCoreInternal.Handler<WorkoutsPlayerCoreInternal.BatchDownload>? = nil, onComplete: WorkoutsPlayerCoreInternal.Handler<Swift.Result<WorkoutsPlayerCoreInternal.Timeline, Swift.Error>>? = nil)
  public func stop()
  @objc deinit
}
public typealias Action = () -> Swift.Void
public typealias ErrorHandler = WorkoutsPlayerCoreInternal.Handler<Swift.Error>
public typealias Generator<T> = () -> T
public typealias Handler<T> = (T) -> Swift.Void
public typealias WorkoutsCoreWrapperViewController = UIKit.UIViewController
public typealias StoryboardType = UIKit.UIStoryboard
public typealias ImageView = UIKit.UIImageView
public typealias Image = UIKit.UIImage
public enum UpdateWorkoutAction : Swift.Codable {
  case metrics(heartRate: Swift.Int, calories: Swift.Int)
  case finish(completedSeconds: Swift.Int)
  case autoAdvance(at: Swift.Int)
  case done(at: Swift.Int)
  case up(at: Swift.Int)
  case down(at: Swift.Int)
  case replace(at: Swift.Int)
  case like(at: Swift.Int)
  case dislike(at: Swift.Int)
  case skip(at: Swift.Int)
  case changeAudioCoachingPreference(WorkoutsPlayerCoreInternal.AudioCoachingPreference)
  case start
  case discard
  public var name: Swift.String {
    get
  }
  public var position: Swift.Int? {
    get
  }
  public var isFinish: Swift.Bool {
    get
  }
  public var isStart: Swift.Bool {
    get
  }
  public var isAutoAdvance: Swift.Bool {
    get
  }
  public var isDone: Swift.Bool {
    get
  }
  public var isSkip: Swift.Bool {
    get
  }
  public var isChangeAudioCoachingPreference: Swift.Bool {
    get
  }
  public func workoutUpdate(workoutId: Swift.Int) -> WorkoutsPlayerCoreInternal.WorkoutUpdate
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol WorkoutUpdate : Swift.Encodable {
  var id: Swift.Int { get }
  func toDictionary(keyEncodingStrategy: Foundation.JSONEncoder.KeyEncodingStrategy) -> [Swift.String : Any]?
}
public struct UpdateWorkoutInfo : Swift.Codable {
  public let id: Swift.Int
  public var action: Swift.String
  public var position: Swift.String?
  public var completedSeconds: Swift.Int?
  public var caloriesBurned: Swift.Int?
  public var averageHeartRate: Swift.Int?
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case id
    case action
    case position
    case completedSeconds
    case caloriesBurned
    case averageHeartRate
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(id: Swift.Int, action: WorkoutsPlayerCoreInternal.UpdateWorkoutAction)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension WorkoutsPlayerCoreInternal.UpdateWorkoutInfo : WorkoutsPlayerCoreInternal.WorkoutUpdate {
}
@objc public class User : ObjectiveC.NSObject, Swift.Codable {
  final public let id: Swift.String
  final public let weight: Swift.Int?
  final public let isSyncingHealthkit: Swift.Bool?
  final public let age: Swift.Int?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc public class WebSocketMessage : ObjectiveC.NSObject, Swift.Codable {
  public var isEventViewerAliveMessage: Swift.Bool {
    get
  }
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc public class Workout : ObjectiveC.NSObject, Swift.Codable {
  public var className: Swift.String?
  public var id: Swift.Int?
  public var format: WorkoutsPlayerCoreInternal.WorkoutFormat?
  public var equipment: Swift.String?
  public var durationSeconds: Swift.Int?
  public var isCompleted: Swift.Bool?
  public var completedAt: Swift.Int64?
  public var completedSeconds: Swift.Int?
  public var averageHeartRate: Swift.Int?
  public var caloriesBurned: Swift.Int?
  public var totalReps: Swift.Int?
  public var totalSets: Swift.Int?
  public var url: Swift.String?
  public var userId: Swift.Int?
  public var streamId: Swift.Int?
  final public let stream: WorkoutsPlayerCoreInternal.Stream?
  public var playlist: [WorkoutsPlayerCoreInternal.WorkoutBlock]?
  public var appliedIntensity: Swift.Int?
  public var appliedMets: Swift.Int?
  final public let coach: WorkoutsPlayerCoreInternal.Coach?
  final public let isAudioDirection: Swift.Bool?
  final public let isAudioForm: Swift.Bool?
  final public let isAudioMotivation: Swift.Bool?
  final public let isAudioPacing: Swift.Bool?
  final public let isAutoAdvance: Swift.Bool?
  public var workoutType: Swift.String?
  public var uuid: Swift.String?
  required public init(from decoder: Swift.Decoder) throws
  public func caloriesCounter(userWeight: Swift.Double, duration: Foundation.TimeInterval) -> Swift.Double?
  public func calculateTotalReps() -> Swift.Int?
  public func calculateTotalSets() -> Swift.Int?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
extension WorkoutsPlayerCoreInternal.Workout {
  public var containsAudioCoachingBlocks: Swift.Bool {
    get
  }
}
extension WorkoutsPlayerCoreInternal.Workout : WorkoutsPlayerCoreInternal.PlayableWorkout {
  public var type: Swift.String? {
    get
  }
  public var identifier: Swift.Int {
    get
  }
  public var durationInSeconds: Foundation.TimeInterval {
    get
  }
  public var workoutSections: [WorkoutsPlayerCoreInternal.PlayableWorkoutSection] {
    get
  }
  public var title: Swift.String {
    get
  }
  public func isBlockAvailableAt(sectionIndex _: Swift.Int, blockIndex _: Swift.Int) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class WorkoutBlock24Go : WorkoutsPlayerCoreInternal.PlayableWorkoutBlock {
  public var level: Swift.Int
  public var intensityBlocks: [WorkoutsPlayerCoreInternal.PlayableBlock]
  public func block(intensity: Swift.Int) -> WorkoutsPlayerCoreInternal.PlayableBlock?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class WorkoutSection : WorkoutsPlayerCoreInternal.PlayableWorkoutSection {
  public var identifier: Swift.String
  public var title: Swift.String
  public var blocks: [WorkoutsPlayerCoreInternal.PlayableWorkoutBlock]
  public func block(atIndex: Swift.Int, intensity: Swift.Int) -> WorkoutsPlayerCoreInternal.PlayableBlock?
  public var numberOfBlocks: Swift.Int {
    get
  }
  @objc deinit
}
extension WorkoutsPlayerCoreInternal.WorkoutBlock : WorkoutsPlayerCoreInternal.PlayableBlock {
  public var canBeReplaced: Swift.Bool {
    get
  }
  public var replacementBlock: WorkoutsPlayerCoreInternal.PlayableBlock? {
    get
  }
  public var intensity: Swift.Int {
    get
  }
  public var identifier: Swift.String {
    get
  }
  public var isEveryMinuteOnTheMinute: Swift.Bool {
    get
  }
  public var numberOfSets: Swift.Int {
    get
  }
  public var repetitions: Swift.Int {
    get
  }
  public var restTimeInSeconds: Foundation.TimeInterval {
    get
  }
  public var durationToShow: Swift.String? {
    get
  }
  public var title: Swift.String {
    get
  }
  public var videoURL: Foundation.URL? {
    get
  }
  public var downloadableURL: Foundation.URL? {
    get
  }
  public var completed: Swift.Bool {
    get
  }
}
@objc public class WorkoutBlock : ObjectiveC.NSObject, Swift.Codable {
  public var audioTimeline: [WorkoutsPlayerCoreInternal.AudioTrack]?
  public var bikePosition: Swift.String?
  public var blockId: Swift.Int?
  public var blockSeconds: Swift.Int?
  public var className: Swift.String?
  public var completedInt: Swift.Int64?
  public var demoHls: Swift.String?
  public var durationSeconds: Swift.Int?
  public var id: Swift.String
  public var incline: Swift.String?
  public var intensityBlocksList: [WorkoutsPlayerCoreInternal.WorkoutBlock]
  public var isAutoAdvance: Swift.Bool?
  public var isEmom: Swift.Bool?
  public var isDownAvailable: Swift.Bool?
  public var isReplaceable: Swift.Bool?
  public var isSkipped: Swift.Bool?
  public var isUpAvailable: Swift.Bool?
  public var level: Swift.Int
  public var load: Swift.String?
  public var mph: Swift.String?
  public var name: Swift.String?
  public var poster: Swift.String?
  public var position: Swift.Int?
  public var reps: Swift.Int?
  public var repsType: Swift.String?
  public var rest: Swift.Int?
  public var resistance: Swift.String?
  public var rpm: Swift.String?
  public var subtitle: Swift.String?
  public var setName: Swift.String?
  public var sets: Swift.Int?
  public var skippedInt: Swift.Int?
  public var speed: Swift.String?
  public var technical: Swift.String?
  public var video1Mp4: Swift.String?
  public var video1Hls: Swift.String?
  public var video2Mp4: Swift.String?
  public var video2Hls: Swift.String?
  public var stepsPerMinute: Swift.String?
  public var stridesPerMinute: Swift.String?
  public var strokesPerMinute: Swift.String?
  public var blockTitle: Swift.String?
  required public init(from decoder: Swift.Decoder) throws
  public func block(intensity: Swift.Int) -> WorkoutsPlayerCoreInternal.PlayableBlock?
  public var intensityBlocks: [WorkoutsPlayerCoreInternal.PlayableBlock] {
    get
  }
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
extension WorkoutsPlayerCoreInternal.WorkoutBlock {
  public var isAudioCoaching: Swift.Bool {
    get
  }
  public var hasToRestartBlockWhenCoachingCuesChange: Swift.Bool {
    get
  }
}
extension WorkoutsPlayerCoreInternal.WorkoutBlock {
  public var videoUrl: Foundation.URL? {
    get
  }
}
extension WorkoutsPlayerCoreInternal.WorkoutBlock {
  public var posterImageUrl: Swift.String? {
    get
  }
}
public enum WorkoutDownloaderResult {
  case failure(Swift.Error)
  case finished(WorkoutsPlayerCoreInternal.DownloadedWorkout)
  case progress(WorkoutsPlayerCoreInternal.DownloadedWorkout)
}
public class DownloadedBlock {
  final public let blockId: Swift.String
  public var videoURL: Foundation.URL
  public var totalBytesWritten: Swift.Int64
  public var totalBytesExpectedToWrite: Swift.Int64
  public var downloadResult: WorkoutsPlayerCoreInternal.DownloadResult?
  public init(blockId: Swift.String, videoURL: Foundation.URL, totalBytesWritten: Swift.Int64 = 0, totalBytesExpectedToWrite: Swift.Int64 = 0, downloadResult: WorkoutsPlayerCoreInternal.DownloadResult? = nil)
  public var progress: Swift.Float {
    get
  }
  @objc deinit
}
public typealias Fetch<Workout> = (@escaping WorkoutsPlayerCoreInternal.Handler<Swift.Result<Workout, Swift.Error>>) -> Swift.Void where Workout : Swift.Decodable, Workout : Swift.Encodable, Workout : WorkoutsPlayerCoreInternal.PlayableWorkout
public class WorkoutDownloader {
  public var downloadedWorkout: WorkoutsPlayerCoreInternal.DownloadedWorkout?
  public init()
  public func downloadWorkout<Workout>(endpoint: (@escaping WorkoutsPlayerCoreInternal.Handler<Swift.Result<Workout, Swift.Error>>) -> Swift.Void, bundle: Foundation.Bundle, onUpdate update: @escaping WorkoutsPlayerCoreInternal.Handler<WorkoutsPlayerCoreInternal.WorkoutDownloaderResult>) where Workout : Swift.Decodable, Workout : Swift.Encodable, Workout : WorkoutsPlayerCoreInternal.PlayableWorkout
  @objc deinit
}
public class DownloadedWorkout {
  final public let workout: WorkoutsPlayerCoreInternal.PlayableWorkout
  public var downloadedBlocks: [WorkoutsPlayerCoreInternal.DownloadedBlock]
  public init(workout: WorkoutsPlayerCoreInternal.PlayableWorkout, downloadedBlocks: [WorkoutsPlayerCoreInternal.DownloadedBlock])
  public var isFinished: Swift.Bool {
    get
  }
  public var progressText: Swift.String {
    get
  }
  @objc deinit
}
public enum WorkoutFormat : Swift.String, Swift.Codable {
  case video
  case list
  public var isList: Swift.Bool {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct BuildWorkoutInfo : Swift.Codable {
  public let streamId: Swift.Int
  public let name: Swift.String
  public var format: Swift.String
  public let poster: Swift.String?
  public var canChangeEquipment: Swift.Bool
  public var canChangeDuration: Swift.Bool
  public var canChangeFormat: Swift.Bool
  public var durationSeconds: Swift.Int?
  public var equipment: Swift.String?
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case streamId
    case name
    case format
    case poster
    case canChangeEquipment
    case canChangeDuration
    case canChangeFormat
    case durationSeconds
    case equipment
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(streamId: Swift.Int, name: Swift.String, format: Swift.String, poster: Swift.String? = nil, durationSeconds: Swift.Int? = nil, equipment: Swift.String? = nil, canChangeEquipment: Swift.Bool = true, canChangeFormat: Swift.Bool = true, canChangeDuration: Swift.Bool = true)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension WorkoutsPlayerCoreInternal.Stream {
  public func asBuildWorkoutInfo() -> WorkoutsPlayerCoreInternal.BuildWorkoutInfo
}
public enum WorkoutPlayerAction : Swift.Codable, Swift.Equatable, Swift.Hashable {
  case airplayTap
  case decreaseIntensity
  case discard
  case dislike
  case finishWorkout
  case increaseIntensity
  case like
  case markBlockDone
  case pause
  case skip
  case resume
  case replaceBlock
  case start
  case volumeTap
  public var title: Swift.String {
    get
  }
  public static func == (a: WorkoutsPlayerCoreInternal.WorkoutPlayerAction, b: WorkoutsPlayerCoreInternal.WorkoutPlayerAction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public protocol WorkoutPlayerDataSource : AnyObject {
  func stateOf(_ player: WorkoutsPlayerCoreInternal.WorkoutPlayer) -> WorkoutsPlayerCoreInternal.WorkoutPlayerState
}
public protocol WorkoutPlayerDelegate : AnyObject {
  func workoutPlayer(_ player: WorkoutsPlayerCoreInternal.WorkoutPlayer, didPerform action: WorkoutsPlayerCoreInternal.WorkoutPlayerAction, onCompletion: WorkoutsPlayerCoreInternal.WorkoutActionHandler?)
}
extension WorkoutsPlayerCoreInternal.WorkoutPlayerDelegate {
  public func workoutPlayer(_ player: WorkoutsPlayerCoreInternal.WorkoutPlayer, didPerform action: WorkoutsPlayerCoreInternal.WorkoutPlayerAction)
}
public protocol WorkoutPlayer {
  var workout: WorkoutsPlayerCoreInternal.PlayableWorkout { get }
}
public enum WorkoutActionResult {
  case success(action: WorkoutsPlayerCoreInternal.WorkoutPlayerAction, workout: WorkoutsPlayerCoreInternal.PlayableWorkout, newState: WorkoutsPlayerCoreInternal.WorkoutPlayerState)
  case failure(action: WorkoutsPlayerCoreInternal.WorkoutPlayerAction, workout: WorkoutsPlayerCoreInternal.PlayableWorkout, error: Swift.Error)
  public var newState: WorkoutsPlayerCoreInternal.WorkoutPlayerState? {
    get
  }
}
public typealias WorkoutActionHandler = WorkoutsPlayerCoreInternal.Handler<WorkoutsPlayerCoreInternal.WorkoutActionResult>
public struct WorkoutPlayerState {
  public init(currentBlockIndex: Swift.Int, currentSectionIndex: Swift.Int, currentIntensity: Swift.Int, isPaused: Swift.Bool = false, followAlongState: WorkoutsPlayerCoreInternal.FollowAlongState? = nil, listPlayerState: WorkoutsPlayerCoreInternal.ListPlayerState? = nil)
  public var currentBlockIndex: Swift.Int
  public var currentSectionIndex: Swift.Int
  public var currentIntensity: Swift.Int
  public var isPaused: Swift.Bool
  public var followAlongState: WorkoutsPlayerCoreInternal.FollowAlongState?
  public var listPlayerState: WorkoutsPlayerCoreInternal.ListPlayerState?
}
public struct FollowAlongState {
  public var availableActions: [WorkoutsPlayerCoreInternal.WorkoutPlayerAction]
  public var currentBlock: WorkoutsPlayerCoreInternal.PlayableBlock
  public var enabledActions: [WorkoutsPlayerCoreInternal.WorkoutPlayerAction]
  public var nextBlock: WorkoutsPlayerCoreInternal.PlayableBlock?
  public var previousBlock: WorkoutsPlayerCoreInternal.PlayableBlock?
}
public struct ListPlayerState {
  public init(listPlayerSections: [WorkoutsPlayerCoreInternal.ListPlayerSectionState])
  public var listPlayerSections: [WorkoutsPlayerCoreInternal.ListPlayerSectionState]
}
public struct ListPlayerSectionState {
  public init(title: Swift.String, blockStates: [WorkoutsPlayerCoreInternal.ListPlayerBlockState])
  public var title: Swift.String
  public var blockStates: [WorkoutsPlayerCoreInternal.ListPlayerBlockState]
}
public struct ListPlayerBlockState {
  public init(block: WorkoutsPlayerCoreInternal.PlayableBlock, isDone: Swift.Bool, intensity: Swift.Int, availableActions: [WorkoutsPlayerCoreInternal.WorkoutPlayerAction], enabledActions: [WorkoutsPlayerCoreInternal.WorkoutPlayerAction])
  public var block: WorkoutsPlayerCoreInternal.PlayableBlock
  public var isDone: Swift.Bool
  public var intensity: Swift.Int
  public var availableActions: [WorkoutsPlayerCoreInternal.WorkoutPlayerAction]
  public var enabledActions: [WorkoutsPlayerCoreInternal.WorkoutPlayerAction]
}
@_hasMissingDesignatedInitializers public class WorkoutPlayerTimer {
  @objc deinit
}
extension Swift.Double {
  public var formattedInMinutesAndSeconds: Swift.String {
    get
  }
}
public protocol WorkoutPlayerTimerDelegate : AnyObject {
  func timer(listPlayerTimer: WorkoutsPlayerCoreInternal.WorkoutPlayerTimer, didUpdate elapsedTime: Foundation.TimeInterval)
}
public struct WorkoutsCoreView : SwiftUI.View {
  public init()
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s26WorkoutsPlayerCoreInternal0aC4ViewV4bodyQrvp", 0) __
}
public struct WorkoutsPlayerCoreInternalSDK {
  public init()
  public func publicMethod()
}
extension WorkoutsPlayerCoreInternal.WorkoutsPlayerCoreInternalSDK : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public var CurrentWorkoutsPlayerEnvironment: WorkoutsPlayerCoreInternal.WorkoutsPlayerEnvironment
public struct WorkoutsPlayerEnvironment {
  public var appGroupIdentifier: Swift.String
  public var audioSessionManager: () -> WorkoutsPlayerCoreInternal.AudioSessionManager
  public var audioPlayer: () -> WorkoutsPlayerCoreInternal.AudioPlayer
  public var calendar: () -> Foundation.Calendar
  public var bundle: () -> Foundation.Bundle
  public var date: () -> Foundation.Date
  public var downloader: () -> WorkoutsPlayerCoreInternal.Downloader
  public var screen: () -> UIKit.UIScreen
  public var imageCache: () -> WorkoutsPlayerCoreInternal.ImageCache
  public static var `default`: WorkoutsPlayerCoreInternal.WorkoutsPlayerEnvironment {
    get
  }
  public static func setup(environment: WorkoutsPlayerCoreInternal.WorkoutsPlayerEnvironment)
  public typealias DownloadImage = (Swift.String, @escaping WorkoutsPlayerCoreInternal.Handler<UIKit.UIImage?>) -> Swift.Void
  public func defaultDownloadImageImplementation() -> WorkoutsPlayerCoreInternal.WorkoutsPlayerEnvironment.DownloadImage
}
extension WorkoutsPlayerCoreInternal.AudioCoachingType : Swift.RawRepresentable {}
extension WorkoutsPlayerCoreInternal.Bump.CodingKeys : Swift.Equatable {}
extension WorkoutsPlayerCoreInternal.Bump.CodingKeys : Swift.Hashable {}
extension WorkoutsPlayerCoreInternal.Bump.CodingKeys : Swift.RawRepresentable {}
extension WorkoutsPlayerCoreInternal.AppError : Swift.Equatable {}
extension WorkoutsPlayerCoreInternal.AppError : Swift.Hashable {}
extension WorkoutsPlayerCoreInternal.InterruptionNotification : Swift.Equatable {}
extension WorkoutsPlayerCoreInternal.InterruptionNotification : Swift.Hashable {}
extension WorkoutsPlayerCoreInternal.InterruptionNotification : Swift.RawRepresentable {}
extension WorkoutsPlayerCoreInternal.ReactiveAudioSnippet.CodingKeys : Swift.Equatable {}
extension WorkoutsPlayerCoreInternal.ReactiveAudioSnippet.CodingKeys : Swift.Hashable {}
extension WorkoutsPlayerCoreInternal.ReactiveAudioSnippet.CodingKeys : Swift.RawRepresentable {}
extension WorkoutsPlayerCoreInternal.SmartWorkoutIntensity : Swift.Hashable {}
extension WorkoutsPlayerCoreInternal.SmartWorkoutIntensity : Swift.RawRepresentable {}
extension WorkoutsPlayerCoreInternal.StorageType : Swift.Equatable {}
extension WorkoutsPlayerCoreInternal.StorageType : Swift.Hashable {}
extension WorkoutsPlayerCoreInternal.Tag.CodingKeys : Swift.Equatable {}
extension WorkoutsPlayerCoreInternal.Tag.CodingKeys : Swift.Hashable {}
extension WorkoutsPlayerCoreInternal.Tag.CodingKeys : Swift.RawRepresentable {}
extension WorkoutsPlayerCoreInternal.UpdateWorkoutInfo.CodingKeys : Swift.Equatable {}
extension WorkoutsPlayerCoreInternal.UpdateWorkoutInfo.CodingKeys : Swift.Hashable {}
extension WorkoutsPlayerCoreInternal.UpdateWorkoutInfo.CodingKeys : Swift.RawRepresentable {}
extension WorkoutsPlayerCoreInternal.WorkoutFormat : Swift.Equatable {}
extension WorkoutsPlayerCoreInternal.WorkoutFormat : Swift.Hashable {}
extension WorkoutsPlayerCoreInternal.WorkoutFormat : Swift.RawRepresentable {}
extension WorkoutsPlayerCoreInternal.BuildWorkoutInfo.CodingKeys : Swift.Equatable {}
extension WorkoutsPlayerCoreInternal.BuildWorkoutInfo.CodingKeys : Swift.Hashable {}
extension WorkoutsPlayerCoreInternal.BuildWorkoutInfo.CodingKeys : Swift.RawRepresentable {}
